#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma <https://tallybark.com/>
# Project: https://github.com/DepoXy/git-put-wise#ðŸ¥¨
# License: MIT

# Copyright (c) Â© 2022-2023 Landon Bouma. All Rights Reserved.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# USAGE:
#
#   GIT_SEQUENCE_EDITOR='/path/to/git-rebase-sort-by-scope-protected-private' \
#     git rebase -i <gitref>

# USETO: This automatic rebase reorders commits based on a couple
#        of special prefixes and rules that the author uses.
#
#        - Reorder commits being rebased using stable sorting:
#          - If commit message has "PRIVATE: " prefix, order latest.
#          - If commit message has "PROTECTED: " prefix, order penultimate
#            to "PRIVATE: ".
#          - For all other commits, leave them (as older ancestors to
#            the "PRIVATE: " and PROTECTED: " commits).
#
#        - This is a "contactless interactive" rebase, so to speak:
#          There is no user interaction involved.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# DEV: Uncomment to show rebase-todo before and after:
#  DX_SHOW_TODO=true
DX_SHOW_TODO=${DX_SHOW_TODO:-false}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# SAVVY: Good-to-know's about being a GIT_SEQUENCE_EDITOR:
#
# - You can `export` environs before `GIT_SEQUENCE_EDITOR=... git rebase ...`
#   to see them herein; but you cannot (obviously) pass back any variables
#   to the caller (though you could use a file to return data).
#
# - Any nonzero return causes git to print the following to stderr:
#     hint: Waiting for your editor to close the file... error:
#       There was a problem with the editor 'git-rebase-sort-by-scope'.
#   And then git-rebase returns 1 (regardless of the exit code here).
#
# - If the rebase-todo is truncated or all commented, git prints to stderr:
#     fatal: No rebase in progress?
#   So the git-rebase caller could redirect stderr and replace with their
#   own message. (This script prints to stdout on error.)
#
# - The current working directory is the repo root.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# REFER: The `awk -i inplace` specifies an awk extension:
#
#   https://www.gnu.org/software/gawk/manual/html_node/Extension-Sample-Inplace.html

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# USAGE: This rebase-resort looks for commit messages with specific prefixing.
#
# - Any commit message that starts with "PROTECTED: " or "PRIVATE: "
#   will be resorted "upwards" chronologically to be the latest commits.
#
#   - The "PRIVATE" commits will bubble up to be the latest commits,
#     and the "PROTECTED" commits will bubble up to follow those.
#
# - You can change the prefixes via the SCOPING_PREFIX and PRIVATE_PREFIX
#   environs, respectively.

# REFER: See the README for why this rebase pattern exists,
#        and how to use it practically.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# Merge commit support
#
# If the scoped commits are trapped in a merge predecessor, a normal
# `git rebase` will drop the merge commits and flatten history (and
# you might have to resolve any conflicts if those merge commits had
# any work in them (though hopefully not, a merge commit with changes
# *is the worst*)).
#
# But we can preserve merge commits with `git rebase --rebase-merges`,
# albeit the rebase-todo is somewhat more complicated.
#
# - REFER: See `man git-rebase` for how "onto", "reset", and "merge" work.
#
# For example, consider the following --rebase-merges todo:
#
#     label onto
#
#     # Branch some-feature-branch
#     reset onto
#     pick 1f329ee A commit message
#     label some-feature-branch
#
#     # Branch other-feature-work
#     reset onto
#     merge -C 0332d4a some-feature-branch # Merge pull request #84 from ...
#     label branch-point
#     pick 8012c54 Another commit message
#     label other-feature-work
#
#     ...
#
#     # Branch starter-main
#     reset branch-point-8 # Merge pull request #96 from ...
#     merge -C a0f5388 a-label-from-above # Merge pull request #97 from ...
#     label starter-main
#
#     reset branch-point-5 # Merge pull request #91 from ...
#     pick f54be6a Update: UX: Improve status message
#     pick ba7bdd8 PRIVATE: WIP
#     pick 7e9ac7d Linting: Add path quotes
#     pick f9265cb PRIVATE: Docs: Private ramblings
#     merge -C 14b1eef starter-main # Merge remote-tracking branch 'starter/main' into release
#
#     # Rebase e171b33..14b1eef onto e171b33 (95 commands)
#     ...
#
# (This is my limited understanding, and I'm just guessing here in parts,
#  just beware:)
#
# The example represents the most common use case:
#
# - That your PRIVATE commits were the latest commits before the merge,
#   whether grouped or not (you might have other new work in there, too).
#
# Therefore, when merging from upstream, your work will be a predecessor
# of the *final* merge.
#
# - This means the code below that rewrites the rebase-todo isn't that
#   much more complicated then it was originally, before merge support
#   was added.
#
#   - If there are no merge commits, the code below simplify moves
#     scoped (PRIVATE and PROTECTED) commits to the bottom of the
#     todo.
#
#   - If there are merge commits, the scoped commits will be moved
#     *after* the final `merge` command.
#
#     - This means that the scoped commits are no longer from a previous
#       branch. They're back to being linear history. Which is fine,
#       because one never publishes scoped commits; they keep getting
#       kicked down the commit road in one's local working project,
#       never really seeing the light of day.
#
# One final thought: "Phew!" I'm relieved we don't have to write a
# complicated rebase-todo parser, because even looking at the
# `merge`-filled rebase-todo example above, it's not obvious how it
# all falls together. (The last reset-pick-pick-merge block makes
# sense, but trying to visualize the different branch work between
# the reset-merge-label-pick-label blocks is eye-fatiguing.)
#
# - In fact, it's an easy change: before this support was added,
#   the `awk` below looked for the first blank like to identify
#   where to put the scoped commits.
#
#   But when --rebase-merges is used, there's a blank like between
#   each of the branch blocks.
#
#   And considering the end of the rebase-todo is just a large
#   comment block, the `awk` can just put the picks are the very
#   END of the document. Such an easy tweak to support merges!
#   (Though beware END prints to stdout, not the -i inplace file.)

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# This is the special tag at the end of the 'exec' line that
# you must use if you git-abort to run that 'exec'.
# - USYNC: This environ is used in git-smart and tig-newtons:
GITSMART_POST_REBASE_EXECS_TAG=" #git-abort"

# Git passes us the full path to the temporary rebase-todo file, e.g.,
#   /path/to/project/.git/rebase-merge/git-rebase-todo
git_rebase_sort_by_scope () {
  local rebase_todo_path="$1"

  # DX: A dev switch and input-waiter useful for debugging the awk.
  print_todo_maybe "${rebase_todo_path}" "before"
  #
  # DEV: If you'd like to view the actual rebase-todo file, stop
  # on git-rebase-interactive here in one terminal, and then poke
  # around with the rebase-todo and awk in another terminal.
  if false && ${DX_SHOW_TODO}; then
    echo "rebase-todo file: ${rebase_todo_path}"
    printf " Are you ready to continue? [Y/n] "
    read -n 1 the_choice
  fi

  # Sort the rebase-todo commits and check for errors along the way.
  awk -i inplace '
    BEGIN { lnum = 0; i_priv = 0; i_prot = 0; }
    {
      if ($0 ~ /^pick [0-9a-f]+ '"${PRIVATE_PREFIX:-PRIVATE: }"'/) {
        private[i_priv] = $0
        i_priv++;
        next
      } else if ($0 ~ /^pick [0-9a-f]+ '"${SCOPING_PREFIX:-PROTECTED: }"'/) {
        protected[i_prot] = $0
        i_prot++;
        next
      }
    }
    { print $0 }
    END {
      # Print PROTECTED commits following release commits.
      for (i_todo = 0; i_todo < i_prot; i_todo++) {
        print protected[i_todo] >> "'${rebase_todo_path}'"
      }
      # Print PRIVATE commits last, following PROTECTED.
      for (i_todo = 0; i_todo < i_priv; i_todo++) {
        print private[i_todo] >> "'${rebase_todo_path}'"
      }
    }
  ' ${rebase_todo_path}

  # ISOFF: The post-rebase exec (optional user hook) is handled
  # by the caller now. But here's how to incorporate it here:
  #
  #   awk -i inplace '
  #     ...
  #     { next }
  #     END {
  #       print "exec '"${GIT_POST_REBASE_EXEC} ${GITSMART_POST_REBASE_EXECS_TAG}"'" \
  #         >> "'${rebase_todo_path}'";
  #     }
  #   ' ${rebase_todo_path}

  print_todo_maybe "${rebase_todo_path}" "after"

  return 0
}

# ***

print_todo_maybe () {
  local rebase_todo_path="$1"
  local context="$2"

  ${DX_SHOW_TODO} || return 0

  >&2 echo
  >&2 echo "rebase-todo ${context}:"
  >&2 echo "$(cat "${rebase_todo_path}" | grep -v "^#")"
  >&2 echo
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  git_rebase_sort_by_scope "${@}"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "${@}"
fi

