#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma <https://tallybark.com/>
# Project: https://github.com/DepoXy/git-put-wise#ðŸ¥¨
# License: MIT

# Copyright (c) Â© 2022-2023 Landon Bouma. All Rights Reserved.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# USAGE:
#
#   GIT_SEQUENCE_EDITOR='/path/to/git-rebase-sort-by-scope-protected-private' \
#     git rebase -i <gitref>

# USETO: This automatic rebase reorders commits based on a couple
#        of special prefixes and rules that the author uses.
#
#        - Reorder commits being rebased using stable sorting:
#          - If commit message has "PRIVATE: " prefix, order latest.
#          - If commit message has "PROTECTED: " prefix, order penultimate
#            to "PRIVATE: ".
#          - For all other commits, leave them (as older ancestors to
#            the "PRIVATE: " and PROTECTED: " commits).
#
#        - This is a "contactless interactive" rebase, so to speak:
#          There is no user interaction involved.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# DEV: Uncomment to show rebase-todo before and after:
#  DX_SHOW_TODO=true
DX_SHOW_TODO=${DX_SHOW_TODO:-false}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# SAVVY: Good-to-know's about being a GIT_SEQUENCE_EDITOR:
#
# - You can `export` environs before `GIT_SEQUENCE_EDITOR=... git rebase ...`
#   to see them herein; but you cannot (obviously) pass back any variables
#   to the caller (though you could use a file to return data).
#
# - Any nonzero return causes git to print the following to stderr:
#     hint: Waiting for your editor to close the file... error:
#       There was a problem with the editor 'git-rebase-sort-by-scope'.
#   And then git-rebase returns 1 (regardless of the exit code here).
#
# - If the rebase-todo is truncated or all commented, git prints to stderr:
#     fatal: No rebase in progress?
#   So the git-rebase caller could redirect stderr and replace with their
#   own message. (This script prints to stdout on error.)
#
# - The current working directory is the repo root.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# REFER: The `awk -i inplace` specifies an awk extension:
#
#   https://www.gnu.org/software/gawk/manual/html_node/Extension-Sample-Inplace.html

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# USAGE: This rebase-resort looks for commit messages with specific prefixing.
#
# - Any commit message that starts with "PROTECTED: " or "PRIVATE: "
#   will be resorted "upwards" chronologically to be the latest commits.
#
#   - The "PRIVATE" commits will bubble up to be the latest commits,
#     and the "PROTECTED" commits will bubble up to follow those.
#
# - You can change the prefixes via the SCOPING_PREFIX and PRIVATE_PREFIX
#   environs, respectively.

# REFER: See the README for why this rebase pattern exists,
#        and how to use it practically.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# Merge commit support
#
# If the scoped commits are trapped in a merge predecessor, a normal
# `git rebase` will drop the merge commits and flatten history (and
# you might have to resolve any conflicts if those merge commits had
# any work in them (though hopefully not, a merge commit with changes
# *is the worst*)).
#
# But we can preserve merge commits with `git rebase --rebase-merges`,
# albeit the rebase-todo is somewhat more complicated.
#
# - REFER: See `man git-rebase` for how "onto", "reset", and "merge" work.
#
# For example, consider the following --rebase-merges todo:
#
#     label onto
#
#     # Branch some-feature-branch
#     reset onto
#     pick 1f329ee A commit message
#     label some-feature-branch
#
#     # Branch other-feature-work
#     reset onto
#     merge -C 0332d4a some-feature-branch # Merge pull request #84 from ...
#     label branch-point
#     pick 8012c54 Another commit message
#     label other-feature-work
#
#     ...
#
#     # Branch starter-main
#     reset branch-point-8 # Merge pull request #96 from ...
#     merge -C a0f5388 a-label-from-above # Merge pull request #97 from ...
#     label starter-main
#
#     reset branch-point-5 # Merge pull request #91 from ...
#     pick f54be6a Update: UX: Improve status message
#     pick ba7bdd8 PRIVATE: WIP
#     pick 7e9ac7d Linting: Add path quotes
#     pick f9265cb PRIVATE: Docs: Private ramblings
#     merge -C 14b1eef starter-main # Merge remote-tracking branch 'starter/main' into release
#
#     # Rebase e171b33..14b1eef onto e171b33 (95 commands)
#     ...
#
# (This is my limited understanding, and I'm just guessing here in parts,
#  just beware:)
#
# The example represents the most common use case:
#
# - That your PRIVATE commits were the latest commits before the merge,
#   whether grouped or not (you might have other new work in there, too).
#
# Therefore, when merging from upstream, your work will be a predecessor
# of the *final* merge.
#
# - This means the code below that rewrites the rebase-todo isn't that
#   much more complicated then it was originally, before merge support
#   was added.
#
#   - If there are no merge commits, the code below simplify moves
#     scoped (PRIVATE and PROTECTED) commits to the bottom of the
#     todo.
#
#   - If there are merge commits, the scoped commits will be moved
#     *after* the final `merge` command.
#
#     - This means that the scoped commits are no longer from a previous
#       branch. They're back to being linear history. Which is fine,
#       because one never publishes scoped commits; they keep getting
#       kicked down the commit road in one's local working project,
#       never really seeing the light of day.
#
# One final thought: "Phew!" I'm relieved we don't have to write a
# complicated rebase-todo parser, because even looking at the
# `merge`-filled rebase-todo example above, it's not obvious how it
# all falls together. (The last reset-pick-pick-merge block makes
# sense, but trying to visualize the different branch work between
# the reset-merge-label-pick-label blocks is eye-fatiguing.)
#
# - In fact, it's an easy change: before this support was added,
#   the `awk` below looked for the first blank like to identify
#   where to put the scoped commits.
#
#   But when --rebase-merges is used, there's a blank like between
#   each of the branch blocks.
#
#   And considering the end of the rebase-todo is just a large
#   comment block, the `awk` can just put the picks are the very
#   END of the document. Such an easy tweak to support merges!
#   (Though beware END prints to stdout, not the -i inplace file.)

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# This is the special tag at the end of the 'exec' line that
# you must use if you git-abort to run that 'exec'.
# - USYNC: This environ is used in git-smart and tig-newtons:
GITSMART_POST_REBASE_EXECS_TAG=" #git-abort"

# Git passes us the full path to the temporary rebase-todo file, e.g.,
#   /path/to/project/.git/rebase-merge/git-rebase-todo
git_rebase_sort_by_scope () {
  local rebase_todo_path="$1"

  # DX: A dev switch and input-waiter useful for debugging the awk.
  print_todo_maybe "${rebase_todo_path}" "before"
  #
  # DEV: If you'd like to view the actual rebase-todo file, stop
  # on git-rebase-interactive here in one terminal, and then poke
  # around with the rebase-todo and awk in another terminal.
  if false && ${DX_SHOW_TODO}; then
    echo "rebase-todo file: ${rebase_todo_path}"
    printf " Are you ready to continue? [Y/n] "
    read -n 1 the_choice
  fi

  # ***

  local exec_cmd="$(print_exec_fcn)"
  # >&2 echo "exec_cmd: ${exec_cmd}"

  # USAGE: Set PW_REBASE_COUNTDOWN_ALWAYS=true to always show countdown.
  # - But on dozens of commits, rebase without exec countdown is almost
  #   instantaneous, whereas rebase with exec countdown takes a noticeable
  #   second.
  #   - So disabled by default, and ENVIRON not advertised/documented.
  #     Will show countdown only when signing, which is a slow op, and
  #     adding progress seems helpful.
  local enable_exec=0
  if ${PW_REBASE_COUNTDOWN_ALWAYS:-false} \
    || [ -s "$(print_rebase_options_gpg_sign_file)" ] \
  ; then
    enable_exec=1
  fi

  # ***

  # Sort the rebase-todo commits and check for errors along the way.
  # - Also discard comment and blank lines.
  # - And use ENDFILE, not END, b/c END sends output to terminal (stdout),
  #   not to the inplace file.
  $(gnu_awk) -i inplace "
    BEGIN {
      i_priv = 0;
      i_prot = 0;
      n_extra_any = 0;
      n_extra_merge = 0;
      enable_exec = ${enable_exec};
    }

    function print_exec_cmd() {
      if (enable_exec) {
        print \"exec ${exec_cmd}; sort_by_scope_exec\" > \"/dev/stdout\";
      }
    }

    {
      if (\$0 ~ /^pick [0-9a-f]+ ${PRIVATE_PREFIX:-PRIVATE: }/) {
        private[i_priv] = \$0
        i_priv++;
        next;
      } else if (\$0 ~ /^pick [0-9a-f]+ ${SCOPING_PREFIX:-PROTECTED: }/) {
        protected[i_prot] = \$0
        i_prot++;
        next;
      } else if (\$0 ~ /^\(label\|merge\|reset\) /) {
        if (i_priv || i_prot) {
          if (\$0 ~ /^merge /) {
            n_extra_merge++;
            if (n_extra_merge > 1) {
              n_extra_any++;
            }
          } else {
            n_extra_any++;
          }
        }
      }
    }
    \$0 ~ /^\$/ { next; }
    \$0 ~ /^#/ { next; }

    # ALTLY: { print \$0; }
    1

    \$0 ~ /^pick / {
      print_exec_cmd();
    }

    ENDFILE {
      if (n_extra_any) {
        print \"WARNING: Scoped commits found deeper than expected\" > \"/dev/stderr\"
      }

      # Print PROTECTED commits following release commits.
      for (i_todo = 0; i_todo < i_prot; i_todo++) {
        print protected[i_todo];
        print_exec_cmd();
      }

      # Print PRIVATE commits last, following PROTECTED.
      for (i_todo = 0; i_todo < i_priv; i_todo++) {
        print private[i_todo];
        print_exec_cmd();
      }
    }
  " ${rebase_todo_path}

  # ISOFF: The post-rebase exec (optional user hook) is handled
  # by the caller now. But here's how to incorporate it here:
  #
  #   awk -i inplace '
  #     ...
  #     { next }
  #     END {
  #       print "exec '"${GIT_POST_REBASE_EXEC} ${GITSMART_POST_REBASE_EXECS_TAG}"'" \
  #         >> "'${rebase_todo_path}'";
  #     }
  #   ' ${rebase_todo_path}

  print_todo_maybe "${rebase_todo_path}" "after"

  return 0
}

# ***

print_todo_maybe () {
  local rebase_todo_path="$1"
  local context="$2"

  ${DX_SHOW_TODO} || return 0

  >&2 echo
  >&2 echo "rebase-todo ${context}:"
  >&2 echo "$(cat "${rebase_todo_path}" | grep -v "^#")"
  >&2 echo
}

# ***

gnu_awk () {
  command -v gawk || command -v awk
}

# ***

prepare_progress_messaging () {
  local n_commits="${1:-0}"

  local progress_orig_msg=""

  local countdown_f="$(print_rebase_countdown_file)"

  printf "%s" "${n_commits}" > "${countdown_f}"

  local prog_prefix="$(print_rebase_prog_prefix)"

  progress_orig_msg="${prog_prefix}${n_commits}..."

  printf "%s" "${progress_orig_msg}"
}

print_rebase_prog_prefix () {
  local prog_prefix

  if [ "$(cat .git/rebase-merge/gpg_sign_opt 2> /dev/null)" = "-S" ]; then
    prog_prefix="Signing commits: "
  else
    prog_prefix="Sorting commits: "
  fi

  printf "%s" "${prog_prefix}"
}

seq_editor_cache_options () {
  local gpg_sign="$1"

  local opts_gpg_sign_f="$(print_rebase_options_gpg_sign_file)"

  printf "%s" "${gpg_sign}" > "${opts_gpg_sign_f}"
}

# Temporary .git/ file used to persist the countdown value.
# - We'll expand this path in the 'exec' string, but you can also 
#   `export PW_REBASE_CACHE_COUNTDOWN=...` from your sell and it
#   will work in the exec (though not export from seq. editor).
PW_REBASE_CACHE_COUNTDOWN="${PW_REBASE_CACHE_COUNTDOWN:-.git/put-wise-countdown}"

print_rebase_countdown_file () {
  printf "%s" "${PW_REBASE_CACHE_COUNTDOWN:-.git/put-wise-countdown}"
}

print_rebase_options_gpg_sign_file () {
  printf "%s" "${PW_REBASE_CACHE_OPTS_GPG_SIGN:-.git/put-wise-opts-gpg-sign}"
}

seq_editor_cleanup_rebase_files () {
  command rm -f -- "$(print_rebase_countdown_file)"
  command rm -f -- "$(print_rebase_options_gpg_sign_file)"
}

# ***

# Remove forbidden newlines, and condense whitespace for readability.
print_exec_fcn () {
  print_exec_fcn_raw \
  | sed -e '/^ *#/d' \
  | tr -d '\n' \
  | sed \
    -e 's/ \+/ /g' \
    -e 's/"/\\"/g'
}

# - git-commit options used to GPG sign via rebase exec:
#     -n : --no-verify (skip hooks)
#     -S : --gpg-sign [${gpg_sign}]
#     --amend : redo current commit
#     --no-edit : use same commit message
#     -q : be quiet, else prints, e.g.,
#          "[detached HEAD 76fc9f4] <message>"

print_exec_fcn_raw () {
  # E.g., ".git/put-wise-countdown"
  local countdown_f="$(print_rebase_countdown_file)"

  # E.g., ".git/put-wise-opts-gpg-sign"
  local opts_gpg_sign_f="$(print_rebase_options_gpg_sign_file)"

  # E.g., "Sorting commits" or "Signing commits"
  local prog_prefix="$(print_rebase_prog_prefix)"

  local gpg_sign_exec=""
  if [ -s "${opts_gpg_sign_f}" ]; then
    gpg_sign_exec="git commit --amend --no-edit --allow-empty --no-verify -S -q;"
  fi

  # SAVVY: Move cursor up one row: \033[1A
  #   So if rebase conflict or error occurs, it prints from
  #   the first column, and not after the progress countdown.
  # - Also print one space after countdown, to clear character
  #   when countdown drops in magnitude, e.g., 100 -> 99, 10 -> 9.

  echo '
    sort_by_scope_exec () {
      set -e;

      cur_count="$(cat "'"${countdown_f}"'")";

      printf "\\r\\033[1A%s%s... \\n" "'"${prog_prefix}"'" "${cur_count}";

      '"${gpg_sign_exec}"'

      printf "%s" "$((${cur_count} - 1))" > "'"${countdown_f}"'";
    }
  '
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  git_rebase_sort_by_scope "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "$@"
fi

