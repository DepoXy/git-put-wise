#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/DepoXy/git-put-wise#ðŸ¥¨
# License: MIT

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# USAGE: See way TMI notes in the sequence-editor script:
#         ~/.depoxy/ambers/bin/seq-editors/sort-by-scope-protected-private

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# NOTES:
#
# If seq. editor refuses to rebase, it prints errors to stdout.
#
# - E.g., git-rebase might fail and emit, "You have unstaged changes".
#
# If the sequence editor fails, git-rebase emits to stderr.
#
# - E.g., "...problem with the editor...", and/or "fatal: No rebase in progress?".

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# SAVVY: If no ${starting_ref}, git-rebase defaults to upstream ancestor.
#
# BWARE: If common ancestor is first-commit, it means the two branches
#        do not share a common history.
#
#        - More importantly, the rebase might conclude with unexpected
#          results, e.g., missing commits.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# This is the known Git rebase todo path.
# - SPIKE: Can we get this from `git` so it's not hardcoded?
GIT_REBASE_TODO_PATH=".git/rebase-merge/git-rebase-todo"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  # Pull in WIP and post-rebase cmds (maybe_stash_changes, git_post_rebase_*).
  # - Also deps/logger.sh, deps/git-nubs.sh, lib/common_*, lib/dep_*.
  . "$(print_project_root)/bin/git-put-wise"
}

print_project_root () {
  printf "%s" "$(dirname -- "$(realpath -- "${BASH_SOURCE[0]}")")/.."
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git-rebase-sort-by-scope-protected-private () {
  local starting_ref="$1"
  local use_magic_starting_ref="${2:-false}"
  local enable_gpg_sign_if_signingkey="${3:-false}"
  local insist_signing_key="${4:-false}"

  # CXREF: ~/.kit/git/git-put-wise/bin/seq-editor-sort-by-scope-protected-private
  local seq_editor
  seq_editor="$(must_locate_seq_editor)" \
    || exit_1

  starting_ref="$(must_verify_starting_ref "${starting_ref}")" \
    || exit_1

  local enable_gpg_sign=${enable_gpg_sign_if_signingkey}

  local gpg_sign
  gpg_sign="$( \
    insist_print_gpg_sign_arg ${enable_gpg_sign_if_signingkey} ${insist_signing_key}
  )" || exit_1

  if [ -z "${gpg_sign}" ]; then
    enable_gpg_sign=false
  fi

  # ***

  local pop_after=false
  pop_after=$(maybe_stash_changes "git-rebase-sort-by-scope-protected-private")

  local head_sha_before_rebase
  head_sha_before_rebase="$(git rev-parse HEAD)"

  local rev_count_before_rebase
  rev_count_before_rebase="$(git rev-list HEAD --count)"

  # ***

  local rebase_boundary=""
  rebase_boundary="$(print_rebase_boundary "${starting_ref}" "${use_magic_starting_ref}")"

  if [ -z "${rebase_boundary}" ]; then
    # Means no rebase boundary identified, but all commits sorted/signed.
    maybe_unstash_changes ${pop_after}

    return 0
  fi

  # Verify rebase_boundary. Called fcn. echoes rebase_boundary, or prints "HEAD".
  must_confirm_shares_history_with_head "${rebase_boundary}" > /dev/null \
    || exit_1

  # Sets already_sorted=true and returns 1 if sorted but not signed; or
  # sets already_sorted=false and returns 1 if not sorted; or
  # returns 0 if sorted, and signed (if requested).
  local already_sorted=false
  if is_already_sorted_and_signed "${rebase_boundary}" "${enable_gpg_sign}"; then
    maybe_unstash_changes ${pop_after}

    return 0
  fi

  # ***

  local rev_list_commits
  rev_list_commits=$(print_git_rev_list_commits "${rebase_boundary}")

  local n_commits
  n_commits="$(git rev-list --count ${rev_list_commits})"

  . "${seq_editor}"

  local progress_orig_msg=""
  if ${PW_REBASE_COUNTDOWN_ALWAYS:-false} || ${enable_gpg_sign}; then \
    progress_orig_msg="$(prepare_progress_messaging "${n_commits}")"

    printf "%s\n" "${progress_orig_msg}"
  fi

  seq_editor_cache_options "${gpg_sign}"

  # ***

  local retcode=0

  git_prepare_push_resort_scoped_and_sign_commits \
    "${seq_editor}" \
    "${gpg_sign}" \
    "${rebase_boundary}" \
    "${already_sorted}" \
    "${n_commits}" \
    "${head_sha_before_rebase}" \
    "${progress_orig_msg}" \
    || retcode=$?

  seq_editor_cleanup_rebase_files

  print_hint_if_rebase_incomplete_or_new_state_suspicious \
    "${head_sha_before_rebase}" "${rev_count_before_rebase}" "${retcode}" \
    || retcode=$?

  # Always run optional user hook (GIT_POST_REBASE_EXEC) and also pop WIP...
  if [ -f "${GIT_REBASE_TODO_PATH}" ]; then
    # ... after rebase finishes (by appending exec to git-rebase-todo).
    git_post_rebase_exec_inject ${pop_after}

    # Remove the progress countdown `exec`'s, because Git prints
    # "Executing: ..." for each exec (and we can't filter them out).
    # - Note that setting '\\r\\033[2A' in the `exec_countdown` fcn.
    #   *sorta* works, but assumes the "Executing: " message was split
    #   across two lines (\033[2A moves the cursor up 2 lines). But even if
    #   that value is correct, the UX is too noisy and impossible to read.
    command sed -i'' "/^exec exec_countdown () {/d" "${GIT_REBASE_TODO_PATH}"
  else
    # ... now.

    # Unstash WIP, and run post-rebase user hooks (GIT_POST_REBASE_EXEC).
    # - TIMED: post-rebase takes a quick but noticeable sec. to run.
    # - SAVVY: Even if before and after HEAD SHA unchanged, if hard link
    #   was involved in any of the rebased commits, the hard link will
    #   have been broken.
    #   - MAYBE/2024-08-24: Avoid post-rebase exec when possible (when
    #     no hard links were harmed during the rebase).
    #     - Altly, can you run exec without calling `mr`?
    #       Because `mr` startup is what's slow.
    git_post_rebase_exec_run ${pop_after}
  fi

  if [ ${retcode} -ne 0 ]; then

    exit_1
  fi

  return 0
}

# ***

must_locate_seq_editor () {
  local seq_editor="$(print_project_root)/bin/seq-editor-sort-by-scope-protected-private"

  if [ ! -e "${seq_editor}" ]; then
    >&2 echo "ERROR: Sequence editor missing or not executable: ${seq_editor}"

    return 1
  fi

  echo "${seq_editor}"
}

# ***

must_verify_starting_ref () {
  local starting_ref="$1"

  if [ -z "${starting_ref}" ]; then
    # Will verify further in print_rebase_boundary
    :
  elif [ "${starting_ref}" = "${PUT_WISE_REBASE_ALL_COMMITS:-ROOT}" ]; then
    >&2 echo "BWARE: Rebasing all commits"
  elif [ "${starting_ref}" = "${GITNUBS_SPECIAL_TIG_SHA_UNSTAGED}" ]; then
    # When run from tig, this is the %(commit) value if user has either
    # Unstaged changes or Staged changes selected.
    # - This is somewhat business logic bleed, i.e., this translation
    #   should probably happen in the tig config. But the tig config code
    #   is a long, heavily escaped, quoted string. So it's usually better
    #   to call out of the config as soon as possible. I.e., we don't mind
    #   doing this here, do we.
    starting_ref="HEAD"
  elif ! git rev-parse "${starting_ref}" >/dev/null 2>&1; then
    # What git-rebase would print.
    >&2 echo "ERROR: fatal: invalid upstream '${starting_ref}'"

    return 1
  elif ! git merge-base --is-ancestor "${starting_ref}" "HEAD"; then
    >&2 echo "ERROR: The starting ref is not an ancestor: '${starting_ref}'"

    return 1
  fi

  printf "%s" "${starting_ref}"
}

# If 'starting_ref' is the latest commit, do the user a solid and replace
# with the upstream branch or pw/in commit.
# - Makes it easy to resort unpublished commits without having to specify
#   the commit, e.g., `git sort-by-scope HEAD true`. (Though more so
#   intended for automation (see '%' `tig` binding in DepoXy project)).
print_rebase_boundary () {
  local starting_ref="$1"
  local use_magic_starting_ref="$2"

  local prog_name="$(basename -- "$0")"

  if ! ${use_magic_starting_ref:-false}; then
    if [ -z "${starting_ref}" ]; then
      >&2 echo "ERROR: Please specify a starting ref to sort & sign from"
      >&2 echo "- E.g, specify a gitref:"
      >&2 echo "    ${prog_name} <REF>"
      >&2 echo "- Or use the special \"ROOT\" ref to sort & sign all commits:"
      >&2 echo "    ${prog_name} ROOT"
      >&2 echo "- Or enable use_magic_starting_ref:"
      >&2 echo "    ${prog_name} \"\" true"

      exit_1
    fi

    printf "%s" "${starting_ref}"

    return 0
  fi

  # Uses: git rev-parse --verify --end-of-options "${gitref}^{commit}" 2> /dev/null
  if [ -n "${starting_ref}" ] && ! git_is_same_commit "${starting_ref}" "HEAD"; then
    printf "%s" "${starting_ref}"

    return 0
  fi

  # Magic starting ref: when user specifies HEAD starting_ref and use-magic,
  # look for specific branches or tags to identify the rebase boundary.

  # Load: put_wise_identify_rebase_boundary_and_remotes
  . "$(print_project_root)/lib/dep_rebase_boundary.sh"

  # The following vars are set by the rebase_boundary, etc., susser:
  local branch_name=""
  local local_release=""
  local remote_release=""
  local remote_protected=""
  local remote_current=""
  local remote_name=""
  local rebase_boundary=""
  local already_sorted=false
  local already_signed=false
  # BWARE: Calls git-fetch, so not the quickest command.
  >&2 put_wise_identify_rebase_boundary_and_remotes \
    "rebase automatically"

  printf "%s" "${rebase_boundary}"
}

# ***

# SAVVY: `git rebase --verbose` prints progress on separate lines, e.g.,
#     Rebasing (1/n)
#     Rebasing (2/n)
#     ...
# - Whereas without it, each "Rebasing (1/n)" message writes to the same
#   line, afterwards being replaced by one final message (on success):
#     Successfully rebased and updated <ref>.

# git-rebase prints each exec, e.g.,
#   Executing: exec_countdown () { ... }
# which we'll filter out.

# Note there's a git-rebase -q|--quiet option, but doesn't seem to
# affect output.

# Note the git-rebase output includes escape sequences, so start-of-line
# matching won't work, e.g.,
#      -e '/^Executing: exec_countdown () { /d' \
#      -e '/^Executing: exec_gpg_sign () { /d' \
#      -e '/^Successfully rebased and updated .*\.$/d' \

# Note this filters "Rebasing (n/N)" progress messages, so that we
# can replace the "Successfully rebased..." message with a custom
# message (as opposed to showing both messages, I know!). But the
# resort generally runs in a split second, faster than you'd care
# about, or could read, in the moment.

git_prepare_push_resort_scoped_and_sign_commits () {
  local seq_editor="$1"
  local gpg_sign="$2"
  local rebase_boundary="$3"
  local already_sorted="$4"
  local n_commits="$5"
  local head_sha_before_rebase="$6"
  local progress_orig_msg="$7"

  local retcode=0

  if [ "${rebase_boundary}" = "${PUT_WISE_REBASE_ALL_COMMITS:-ROOT}" ]; then
    rebase_boundary="--root"
  fi

  local errs
  errs="$( \
    GIT_SEQUENCE_EDITOR="${seq_editor}" \
      git -c color.advice=always rebase -i --rebase-merges ${rebase_boundary} 3>&1 >&2 2>&3 3>&- \
      | sed \
        -e '/Rebasing ([0-9]\+\/[0-9]\+)/d' \
        -e '/Executing: exec_countdown () { /d' \
        -e '/Executing: exec_gpg_sign () { /d' \
        -e '/Successfully rebased and updated .*\.$/d' \
      | tr -d '\r';
    return ${PIPESTATUS[0]}
  )" \
    || retcode=$?

  if [ -n "${errs}" ] || [ ${retcode} -ne 0 ]; then
    >&2 echo
    >&2 echo "ERROR: \`git rebase\` failed (${retcode}):"
    >&2 echo
    echo "${errs}" | >&2 sed 's/^/  /'
    if [ ${retcode} -eq 0 ]; then

      retcode=1
    fi
  elif [ -f "${GIT_REBASE_TODO_PATH}" ]; then
    # SAVVY: This might happen if you put a "break" in the rebase-todo.
    >&2 echo
    >&2 echo "ERROR: \`git rebase\` stopped. Please investigate!"
    >&2 echo "- Previous HEAD: ${head_sha_before_rebase}"
    >&2 echo

    retcode=1
  else
    if [ -n "${progress_orig_msg}" ]; then
      local one_line_up="\033[1A"
      # Wipe out final 'pick' progress message.
      # - Move to first column (\r), and one_line_up).
      printf "\r${one_line_up}%s\r" "$(echo "${progress_orig_msg}" | sed 's/./ /g')"
    fi

    print_sorted_and_signed_message "${gpg_sign}" "${already_sorted}" \
      "${n_commits}" "${head_sha_before_rebase}"
  fi

  return ${retcode}
}

print_hint_if_rebase_incomplete_or_new_state_suspicious () {
  local head_sha_before_rebase="$1"
  local rev_count_before_rebase="$2"
  local sort_and_sign_retcode="$3"

  if [ ${sort_and_sign_retcode} -ne 0 ] || [ -f "${GIT_REBASE_TODO_PATH}" ]; then
    echo
    echo "Looks like you got work to do!"

    return 1
  else
    local unexpected_changes_detected=false

    if [ -n "$(git diff ${head_sha_before_rebase}..HEAD)" ]; then
      >&2 echo
      >&2 echo "BWARE: The sort-by-scope resulted in changes."

      unexpected_changes_detected=true
    fi

    local rev_count_after_rebase
    rev_count_after_rebase="$(git rev-list HEAD --count)"

    if [ ${rev_count_before_rebase} -ne ${rev_count_after_rebase} ]; then
      >&2 echo "BWARE: The number of commits before and after rebase has changed."
      >&2 echo "- Count before: ${rev_count_before_rebase} / Count after: ${rev_count_after_rebase}"

      unexpected_changes_detected=true
    fi

    if ${unexpected_changes_detected}; then
      >&2 echo "- If you had to resolve conflicts, maybe this was you."
      >&2 echo "- If not, perhaps you should investigate."
      >&2 echo "Previous HEAD: ${head_sha_before_rebase}"
      >&2 echo "- Try:"
      >&2 echo
      >&2 echo "    git diff ${head_sha_before_rebase}..HEAD"

      return 1
    fi
  fi

  return 0
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  set -e

  # Load: set_traps, clear_traps, exit_0, exit_1, os_is_macos.
  . "$(dirname -- "$(realpath -- "$0")")/../deps/sh-err-trap/lib/err-trap.sh"

  set_traps

  source_deps

  git-rebase-sort-by-scope-protected-private "$@"

  clear_traps
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "$@"
fi

