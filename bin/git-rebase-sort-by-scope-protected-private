#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/DepoXy/git-put-wise#ðŸ¥¨
# License: MIT

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# USAGE: See way TMI notes in the sequence-editor script:
#         ~/.depoxy/ambers/bin/seq-editors/sort-by-scope-protected-private

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# NOTES:
#
# If seq. editor refuses to rebase, it prints errors to stdout.
#
# - E.g., git-rebase might fail and emit, "You have unstaged changes".
#
# If the sequence editor fails, git-rebase emits to stderr.
#
# - E.g., "...problem with the editor...", and/or "fatal: No rebase in progress?".

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# SAVVY: If no ${starting_ref}, git-rebase defaults to upstream ancestor.
#
# BWARE: If common ancestor is first-commit, it means the two branches
#        do not share a common history.
#
#        - More importantly, the rebase might conclude with unexpected
#          results, e.g., missing commits.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# This is the known Git rebase todo path.
# - SPIKE: Can we get this from `git` so it's not hardcoded?
GIT_REBASE_TODO_PATH=".git/rebase-merge/git-rebase-todo"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  # Pull in WIP and post-rebase cmds (maybe_stash_changes, git_post_rebase_*).
  # - Also deps/logger.sh, deps/git-nubs.sh, lib/common_*, lib/dep_*.
  . "$(print_project_root)/bin/git-put-wise"
}

print_project_root () {
  printf "%s" "$(dirname -- "$(realpath -- "${BASH_SOURCE[0]}")")/.."
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git-rebase-sort-by-scope-protected-private () {
  local starting_ref="$1"
  local use_magic_starting_ref="${2:-false}"
  local enable_gpg_sign="${3:-false}"
  local insist_signing_key="${4:-false}"

  # CXREF: ~/.kit/git/git-put-wise/bin/seq-editor-sort-by-scope-protected-private
  local seq_editor
  seq_editor="$(must_locate_seq_editor)" \
    || return $?

  must_verify_starting_ref "${starting_ref}"

  local gpg_sign
  gpg_sign="$(insist_print_gpg_sign_arg ${enable_gpg_sign} ${insist_signing_key})"

  # ***

  local pop_after=false
  pop_after=$(maybe_stash_changes "git-rebase-sort-by-scope-protected-private")

  local head_sha_before_rebase
  head_sha_before_rebase="$(git rev-parse HEAD)"

  local rev_count_before_rebase
  rev_count_before_rebase="$(git rev-list HEAD --count)"

  local sort_from_commit=""
  sort_from_commit="$(print_sort_from_commit "${starting_ref}" \
    "${use_magic_starting_ref}" "${head_sha_before_rebase}")"

  # ***

  local already_sorted=false

  # Sets already_sorted=true and returns 1 if sorted but not signed;
  # Or sets already_sorted=false and returns 1 if not sorted; or
  # returns 0 if sorted, and signed if requested.
  if is_already_sorted_and_signed "${sort_from_commit}" ${enable_gpg_sign}; then
    maybe_unstash_changes ${pop_after}

    return 0
  fi

  # ***

  local n_commits
  n_commits="$(git rev-list --count ${sort_from_commit}..HEAD)"

  . "${seq_editor}"

  local progress_orig_msg
  progress_orig_msg="$(prepare_progress_messaging "${n_commits}")"

  printf "%s\n" "${progress_orig_msg}"

  seq_editor_cache_options "${gpg_sign}"

  # ***

  # SAVVY: `git rebase --verbose` prints progress on separate lines, e.g.,
  #     Rebasing (1/n)
  #     Rebasing (2/n)
  #     ...
  # - Whereas without it, each "Rebasing (1/n)" message writes to the same
  #   line, afterwards being replaced by one final message (on success):
  #     Successfully rebased and updated <ref>.
  
  # Note there's a git-rebase -q|--quiet option, but doesn't seem to
  # affect output.

  # Note the git-rebase output includes escape sequences, so start-of-line
  # matching won't work, e.g.,
  #      -e '/^Executing: sort_by_scope_exec () { /d' \
  #      -e '/^Successfully rebased and updated .*\.$/d' \

  local retcode=0

  local errs
  errs="$( \
    GIT_SEQUENCE_EDITOR="${seq_editor}" \
      git -c color.advice=always rebase -i --rebase-merges ${sort_from_commit} 3>&1 >&2 2>&3 3>&- \
      | sed \
        -e 's/Rebasing ([0-9]\+\/[0-9]\+)\r//' \
        -e '/Executing: sort_by_scope_exec () { /d' \
        -e '/Successfully rebased and updated .*\.$/d' \
      | tr -d '\r';
    return ${PIPESTATUS[0]}
  )" \
    || retcode=$?

  if [ -n "${errs}" ] || [ ${retcode} != 0 ]; then
    >&2 echo
    >&2 echo "ERROR: \`git rebase\` failed (${retcode}):"
    >&2 echo
    echo "${errs}" | >&2 sed 's/^/  /'
  else
    # Wipe out final 'pick' progress message.
    # - Move to first column, and one line up.
    printf "\r\033[1A%s" "$(echo "${progress_orig_msg}" | sed 's/./ /g')"
    local msg_verb="Sorted"
    if [ -n "${gpg_sign}" ]; then
      if ${already_sorted}; then
        msg_verb="Signed"
      else
        msg_verb="${msg_verb} & signed"
      fi
    fi
    printf "\r%s\n" "âœ“ ${msg_verb} ${n_commits} commit(s)"
  fi

  seq_editor_cleanup_rebase_files

  print_hint_if_rebase_incomplete_or_new_state_suspicious \
    "${head_sha_before_rebase}" "${rev_count_before_rebase}" "${retcode}"

  # Always run optional user hook (GIT_POST_REBASE_EXEC) and also pop WIP...
  if [ ${retcode} -ne 0 ] && [ -f "${GIT_REBASE_TODO_PATH}" ]; then
    # ... after rebase finishes (by appending exec to git-rebase-todo).
    git_post_rebase_exec_inject ${pop_after}

    # Remove the progress countdown `exec`'s, because Git prints "Executing: ..."
    # for each exec, which defeats the purpose.
    # - Note that setting '\\r\\033[2A' in the `sort_by_scope_exec` fcn.
    #   *sorta* works, but assumes the "Executing: " message was split
    #   across two lines (\033[2A moves the cursor up 2 lines). But even if
    #   that value is correct, the UX is too noisy and impossible to read.
    command sed -i'' "/^exec sort_by_scope_exec () {/d" "${GIT_REBASE_TODO_PATH}"
  else
    # ... now.

    # Unstash WIP, and run post-rebase user hooks (GIT_POST_REBASE_EXEC).
    # - TIMED: post-rebase takes a quick but noticeable sec. to run.
    # - SAVVY: Even if before and after HEAD SHA unchanged, if hard link
    #   was involved in any of the rebased commits, the hard link will
    #   have been broken.
    #   - MAYBE/2024-08-24: Avoid post-rebase exec when possible (when
    #     no hard links were harmed during the rebase).
    #     - Altly, can you run exec without calling `mr`?
    #       Because `mr` startup is what's slow.
    git_post_rebase_exec_run ${pop_after}
  fi

  return ${retcode}
}

# ***

must_locate_seq_editor () {
  local seq_editor="$(print_project_root)/bin/seq-editor-sort-by-scope-protected-private"

  if [ ! -e "${seq_editor}" ]; then
    >&2 echo "ERROR: Sequence editor missing or not executable: ${seq_editor}"

    return 1
  fi

  echo "${seq_editor}"
}

# ***

must_verify_starting_ref () {
  local starting_ref="$1"

  if [ -z "${starting_ref}" ]; then
    >&2 echo "ERROR: Please specify the rebase starting gitref"

    return 1
  fi

  if ! git rev-parse "${starting_ref}" >/dev/null 2>&1; then
    # What git-rebase would print.
    >&2 echo "ERROR: fatal: invalid upstream '${starting_ref}'"

    return 1
  fi

  if ! git merge-base --is-ancestor "${starting_ref}" "HEAD"; then
    >&2 echo "ERROR: The starting ref is not an ancestor: '${starting_ref}'"

    return 1
  fi

  return 0
}

# If 'starting_ref' is the latest commit, do the user a solid and replace
# with the upstream branch or pw/in commit.
# - Makes it easy to resort unpublished commits without having to specify
#   the commit, e.g., `git sort-by-scope HEAD true`. (Though more so
#   intended for automation (see '%' `tig` binding in DepoXy project)).
print_sort_from_commit () {
  local starting_ref="$1"
  local use_magic_starting_ref="$2"
  local head_sha_before_rebase="$3"

  if ! ${use_magic_starting_ref:-false}; then
    printf "%s" "${starting_ref}"

    return 0
  fi

  # Uses: git rev-parse --verify --end-of-options "${gitref}^{commit}" 2> /dev/null
  if ! git_is_same_commit "${starting_ref}" "${head_sha_before_rebase}"; then
    printf "%s" "${starting_ref}"

    return 0
  fi

  # Load: put_wise_suss_push_vars_and_rebase_sort_by_scope_automatic
  . "$(print_project_root)/lib/put_wise_push_remotes.sh"

  # The following vars are set by the sort_from_commit, etc., susser:
  local branch_name=""
  local local_release=""
  local remote_release=""
  local remote_liminal=""
  local remote_protected=""
  local remote_current=""
  local remote_name=""
  local sort_from_commit=""
  # BWARE: Calls git-fetch, so not the quickest command.
  >&2 put_wise_suss_push_vars_and_rebase_sort_by_scope_automatic \
    "rebase automatically"

  printf "%s" "${sort_from_commit}"
}

# ***

# If already sorted by scope and signing declined,
# or already sorted and signing requested and verified,
# return true, and caller will return without running rebase.
#
# - Running the rebase anyway is generally fast, and the final HEAD SHA
#   remains unchanged. But this way we can also skip the user's
#   post-rebase exec, which might not be so fast (e.g., DepoXy uses the
#   post-rebase exec to call `mr` to repair hard links, and `mr` is slow
#   to load (at least author's is, will uses lots of mrconfig files)).
#
# Side-effect: Sets already_sorted=true|false

is_already_sorted_and_signed () {
  local sort_from_commit="$1"
  local enable_gpg_sign="$2"

  already_sorted=false

  local scoped_count

  if scoped_count="$(is_sorted_by_scope "${sort_from_commit}")"; then
    already_sorted=true

    echo "âœ“ Verified ${scoped_count} scoped commit(s)"

    if ! ${enable_gpg_sign} \
      || is_gpg_signed_since_commit "${sort_from_commit}" \
    ; then

      return 0
    fi
  fi

  return 1
}

# ***

print_hint_if_rebase_incomplete_or_new_state_suspicious () {
  local head_sha_before_rebase="$1"
  local rev_count_before_rebase="$2"
  local retcode="$3"

  if [ -f "${GIT_REBASE_TODO_PATH}" ]; then
    # git-rebase exited 1.
    echo
    echo "Looks like you got work to do!"
    # git-rebase exited nonzero. If not, our code is wrong.
    if [ ${retcode} -eq 0 ]; then
      echo
      echo "ERROR: rebase-todo found, but git-rebase exited zero"
    fi
  else
    local unexpected_changes_detected=false

    if [ -n "$(git diff ${head_sha_before_rebase}..HEAD)" ]; then
      >&2 echo
      >&2 echo "BWARE: The sort-by-scope resulted in changes."

      unexpected_changes_detected=true
    fi

    local rev_count_after_rebase
    rev_count_after_rebase="$(git rev-list HEAD --count)"

    if [ ${rev_count_before_rebase} -ne ${rev_count_after_rebase} ]; then
      >&2 echo "BWARE: The number of commits before and after rebase has changed."
      >&2 echo "- Count before: ${rev_count_before_rebase} / Count after: ${rev_count_after_rebase}"

      unexpected_changes_detected=true
    fi

    if ${unexpected_changes_detected}; then
      >&2 echo "- If you had to resolve conflicts, maybe this was you."
      >&2 echo "- If not, perhaps you should investigate."
      >&2 echo "Previous HEAD: ${head_sha_before_rebase}"
      >&2 echo "- Try:"
      >&2 echo
      >&2 echo "    git diff ${head_sha_before_rebase}..HEAD"
    fi

    # git-rebase exited zero. If not, our code is wrong.
    # - Or I (lb) assume it is. Obviously, git-rebase can fail for other,
    #   non-conflict reasons (e.g., bad args), but I assume the way the
    #   code works that it won't.
    if [ ${retcode} -ne 0 ]; then
      echo
      echo "ERROR: rebase-todo not found, but git-rebase exited nonzero"
    fi
  fi
}

# ***

# Returns '--gpg-sign' git-rebase arg if caller requested it.
# - Also checks if signing key is expected to be present,
#   otherwise Git fails, e.g.,
#     $ git rebase --exec 'git commit --amend --no-edit -n -S' <sha>
#     ...
#     error: gpg failed to sign the data
#     ...

insist_print_gpg_sign_arg () {
  local enable_gpg_sign="$1"
  local insist_signing_key="$2"

  local gpg_sign=""

  if ${enable_gpg_sign} \
    && [ "$(git config put-wise.sign-before-push)" = "true" ] \
  ; then
    if ${insist_signing_key} && [ -z "$(git config user.signingkey)" ]; then
      >&2 echo "ERROR: Cannot sign: Please specify user.signingkey in your Git config"

      return 1
    fi

    gpg_sign="--gpg-sign"
  fi

  printf "%s" "${gpg_sign}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  set -e

  source_deps

  git-rebase-sort-by-scope-protected-private "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "$@"
fi

