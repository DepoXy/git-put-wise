#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/DepoXy/git-put-wise#ðŸ¥¨
# License: MIT

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# USAGE: See way TMI notes in the sequence-editor script:
#         ~/.depoxy/ambers/bin/seq-editors/sort-by-scope-protected-private

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# NOTES:
#
# If seq. editor refuses to rebase, it prints errors to stdout.
#
# - E.g., git-rebase might fail and emit, "You have unstaged changes".
#
# If the sequence editor fails, git-rebase emits to stderr.
#
# - E.g., "...problem with the editor...", and/or "fatal: No rebase in progress?".

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# SAVVY: If no ${starting_ref}, git-rebase defaults to upstream ancestor.
#
# BWARE: If common ancestor is first-commit, it means the two branches
#        do not share a common history.
#
#        - More importantly, the rebase might conclude with unexpected
#          results, e.g., missing commits.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# This is the known Git rebase todo path.
# - SPIKE: Can we get this from `git` so it's not hardcoded?
GIT_REBASE_TODO_PATH=".git/rebase-merge/git-rebase-todo"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  # Pull in WIP and post-rebase cmds (maybe_stash_changes, git_post_rebase_*).
  # - Also deps/logger.sh, deps/git-nubs.sh, lib/common_*, lib/dep_*.
  . "$(print_project_root)/bin/git-put-wise"
}

print_project_root () {
  printf "%s" "$(dirname -- "$(realpath -- "${BASH_SOURCE[0]}")")/.."
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git-rebase-sort-by-scope-protected-private () {
  local starting_ref="$1"
  local use_magic_starting_ref="${2:-false}"
  local enable_gpg_sign="${3:-false}"
  local insist_signing_key="${4:-false}"

  # CXREF: ~/.kit/git/git-put-wise/bin/seq-editor-sort-by-scope-protected-private
  local seq_editor
  seq_editor="$(must_locate_seq_editor)" \
    || return $?

  must_verify_starting_ref "${starting_ref}"

  local gpg_sign
  gpg_sign="$(insist_print_gpg_sign_arg "${enable_gpg_sign}" ${insist_signing_key})"

  local pop_after=false
  pop_after=$(maybe_stash_changes "git-rebase-sort-by-scope-protected-private")

  local head_sha_before_rebase
  head_sha_before_rebase="$(git rev-parse HEAD)"

  local rev_count_before_rebase
  rev_count_before_rebase="$(git rev-list HEAD --count)"

  local sort_from_commit=""
  sort_from_commit="$(print_sort_from_commit "${starting_ref}" \
    "${use_magic_starting_ref}" "${head_sha_before_rebase}")"

  local retcode=0

  GIT_SEQUENCE_EDITOR="${seq_editor}" \
    git rebase -i --rebase-merges ${gpg_sign} ${sort_from_commit} \
      || retcode=$?

  print_hint_if_rebase_incomplete_or_new_state_suspicious \
    "${head_sha_before_rebase}" "${rev_count_before_rebase}" "${retcode}"

  # Always run optional user hook (GIT_POST_REBASE_EXEC) and also pop WIP...
  if [ ${retcode} -ne 0 ] && [ -f "${GIT_REBASE_TODO_PATH}" ]; then
    # ... after rebase finishes (by appending rebase-todo).
    git_post_rebase_exec_inject ${pop_after}
  else
    # ... now.

    if [ ${retcode} -eq 0 ]; then
      force_rebase_and_resign_maybe "${gpg_sign}" "${head_sha_before_rebase}" \
        "${sort_from_commit}" \
        || retcode=$?
    fi

    if [ ${retcode} -ne 0 ] && [ -f "${GIT_REBASE_TODO_PATH}" ]; then
      # ... after rebase finishes (by appending rebase-todo).
      git_post_rebase_exec_inject ${pop_after}
    else
      # ... now.
      # - Unstashes, and runs post-rebase user hooks (GIT_POST_REBASE_EXEC).
      git_post_rebase_exec_run ${pop_after}
    fi
  fi

  return ${retcode}
}

# ***

must_locate_seq_editor () {
  local seq_editor="$(print_project_root)/bin/seq-editor-sort-by-scope-protected-private"

  if [ ! -e "${seq_editor}" ]; then
    >&2 echo "ERROR: Sequence editor missing or not executable: ${seq_editor}"

    return 1
  fi

  echo "${seq_editor}"
}

# ***

must_verify_starting_ref () {
  local starting_ref="$1"

  if [ -z "${starting_ref}" ]; then
    >&2 echo "ERROR: Please specify the rebase starting gitref"

    return 1
  fi

  if ! git rev-parse "${starting_ref}" >/dev/null 2>&1; then
    # What git-rebase would print.
    >&2 echo "ERROR: fatal: invalid upstream '${starting_ref}'"

    return 1
  fi

  if ! git merge-base --is-ancestor "${starting_ref}" "HEAD"; then
    >&2 echo "ERROR: The starting ref is not an ancestor: '${starting_ref}'"

    return 1
  fi

  return 0
}

# If 'starting_ref' is the latest commit, do the user a solid and replace
# with the upstream branch or pw/in commit.
# - Makes it easy to resort unpublished commits without having to specify
#   the commit, e.g., `git sort-by-scope HEAD true`. (Though more so
#   intended for automation (see '%' `tig` binding in DepoXy project)).
print_sort_from_commit () {
  local starting_ref="$1"
  local use_magic_starting_ref="$2"
  local head_sha_before_rebase="$3"

  if ! ${use_magic_starting_ref:-false}; then
    printf "%s" "${starting_ref}"

    return 0
  fi

  # Uses: git rev-parse --verify --end-of-options "${gitref}^{commit}" 2> /dev/null
  if ! git_is_same_commit "${starting_ref}" "${head_sha_before_rebase}"; then
    printf "%s" "${starting_ref}"

    return 0
  fi

  # Load: put_wise_suss_push_vars_and_rebase_sort_by_scope_automatic
  . "$(print_project_root)/lib/put_wise_push_remotes.sh"

  # The following vars are set by the sort_from_commit, etc., susser:
  local branch_name=""
  local local_release=""
  local remote_release=""
  local remote_liminal=""
  local remote_protected=""
  local remote_current=""
  local remote_name=""
  local sort_from_commit=""
  # BWARE: Calls git-fetch, so not the quickest command.
  >&2 put_wise_suss_push_vars_and_rebase_sort_by_scope_automatic \
    "rebase automatically"

  printf "%s" "${sort_from_commit}"
}

# ***

print_hint_if_rebase_incomplete_or_new_state_suspicious () {
  local head_sha_before_rebase="$1"
  local rev_count_before_rebase="$2"
  local retcode="$3"

  if [ -f "${GIT_REBASE_TODO_PATH}" ]; then
    # git-rebase exited 1.
    echo
    echo "Looks like you got work to do!"
    # git-rebase exited nonzero. If not, our code is wrong.
    if [ ${retcode} -eq 0 ]; then
      echo
      echo "ERROR: rebase-todo found, but git-rebase exited zero"
    fi
  else
    local unexpected_changes_detected=false

    if [ -n "$(git diff ${head_sha_before_rebase}..HEAD)" ]; then
      >&2 echo
      >&2 echo "BWARE: The sort-by-scope resulted in changes."

      unexpected_changes_detected=true
    fi

    local rev_count_after_rebase
    rev_count_after_rebase="$(git rev-list HEAD --count)"

    if [ ${rev_count_before_rebase} -ne ${rev_count_after_rebase} ]; then
      >&2 echo "BWARE: The number of commits before and after rebase has changed."
      >&2 echo "- Count before: ${rev_count_before_rebase} / Count after: ${rev_count_after_rebase}"

      unexpected_changes_detected=true
    fi

    if ${unexpected_changes_detected}; then
      >&2 echo "- If you had to resolve conflicts, maybe this was you."
      >&2 echo "- If not, perhaps you should investigate."
      >&2 echo "Previous HEAD: ${head_sha_before_rebase}"
      >&2 echo "- Try:"
      >&2 echo
      >&2 echo "    git diff ${head_sha_before_rebase}..HEAD"
    fi

    # git-rebase exited zero. If not, our code is wrong.
    # - Or I (lb) assume it is. Obviously, git-rebase can fail for other,
    #   non-conflict reasons (e.g., bad args), but I assume the way the
    #   code works that it won't.
    if [ ${retcode} -ne 0 ]; then
      echo
      echo "ERROR: rebase-todo not found, but git-rebase exited nonzero"
    fi
  fi
}

# ***

# Returns '--gpg-sign' git-rebase arg if caller requested it.
# - Also checks if signing key is expected to be present,
#   otherwise Git fails, e.g.,
#     $ git rebase --exec 'git commit --amend --no-edit -n -S' <sha>
#     ...
#     error: gpg failed to sign the data
#     ...

insist_print_gpg_sign_arg () {
  local enable_gpg_sign="$1"
  local insist_signing_key="$2"

  local gpg_sign=""

  if ${enable_gpg_sign} \
    && [ "$(git config put-wise.sign-before-push)" = "true" ] \
  ; then
    if ${insist_signing_key} && [ -z "$(git config user.signingkey)" ]; then
      >&2 echo "ERROR: Cannot sign: Please specify user.signingkey in your Git config"

      return 1
    fi

    gpg_sign="--gpg-sign"
  fi

  printf "%s" "${gpg_sign}"
}

# ***

# - git-commit options used below:
#     -n : --no-verify (skip hooks)
#     -S : --gpg-sign [${gpg_sign}]
#     --amend : redo current commit
#     --no-edit : use same commit message
#     -q : be quiet, else prints, e.g.,
#          "[detached HEAD 76fc9f4] <message>"
#
# - git-rebase itself prints each exec, e.g.,
#     Executing: git commit --amend --no-edit -n -S
#   which we'll dispose of and replace with our own countdown.
#
# - Note the `declare -f` Bashism, which lets us avoid needing
#   to tediously escape the exec, e.g., avoids this:
#     git rebase --exec " \
#       foo () { \
#         local cur_count=\"$(cat \"${countdown_f}\")\"; \
#         printf \"\b\b\b\b%s...\" \"${cur_count}\"; \
#         git commit --amend --no-edit -n -S -q; \
#         printf \"%s\" \"$((${cur_count} - 1))\" > \"${countdown_f}\" \
#       }; foo" ${starting_ref}
#
# - As an alternative to git-rebase, we could use the old `git filter-branch`.
#   - But not the newer `git filter-repo`, which does not support GPG signing
#     (tho someday?): https://github.com/newren/git-filter-repo/issues/67
#   - And `git filter-branch` has its drawbacks:
#     - In the author's completely unscientific and didn't-use-that-many-
#       commits and-it-was-just-one-test test, to resign 9 commits took
#       git-rebase 2s, and it took git filter-branch 3s.
#     - git filter-branch also prints a warning:
#         WARNING: git-filter-branch has a glut of gotchas generating mangled history
#            rewrites.  Hit Ctrl-C before proceeding to abort, then use an
#            alternative filtering tool such as 'git filter-repo'
#            (https://github.com/newren/git-filter-repo/) instead.  See the
#            filter-branch manual page for more details; to squelch this warning,
#            set FILTER_BRANCH_SQUELCH_WARNING=1.
#         Proceeding with filter-branch...
#       - And then proceeds anyway before you have time to read the whole message,
#         ha.
#     - In any case, for resigning, the author *guesses* it's "safe" to use
#       filter-branch, which you could try, e.g.,
#         FILTER_BRANCH_SQUELCH_WARNING=1 \
#           git filter-branch --commit-filter 'git commit-tree -S "$@";' ${starting_ref}..HEAD
#       but, as noted, it's not likely to be any faster.
#       Also then we can't use our own countdown progress display.
#
# REFER/THANX: https://superuser.com/questions/397149/can-you-gpg-sign-old-commits
#   https://stackoverflow.com/questions/66843980/resign-previous-git-commits-with-a-new-gpg-key

force_rebase_and_resign_maybe () {
  local gpg_sign="$1"
  local head_sha_before_rebase="$2"
  local starting_ref="$3"

  if [ -z "${gpg_sign}" ]; then

    return 0
  fi
  
  local head_sha_after_rebase
  head_sha_after_rebase="$(git rev-parse HEAD)"

  if [ "${head_sha_after_rebase}" != "${head_sha_before_rebase}" ]; then
    # The rebase that just ran signed the commits.

    return 0
  fi

  # Else, the git-rebase that was previously called didn't change anything,
  # so we can use `git rebase --exec` to force it.
  #
  # But first check if the commits are already signed.

  local n_commits
  n_commits="$(git rev-list --count ${starting_ref}..HEAD)"

  # Check if already signed.
  # - %G? : "G" for good/valid sig, "B" for bad, "U" for good w/ unknown validity,
  #         "X" for good but expired, "Y" for good made by expired key,
  #         "R" for good made by revoked key, "E" if sig cannot be checked
  #         (e.g. missing key) and "N" for no signature
  if ! git log --format="%G?" ${starting_ref}..HEAD | grep -q -e 'N'; then
    echo "Verified ${n_commits} commit(s) already signed."

    return 0
  fi

  rebase_and_resign "${starting_ref}" "${n_commits}"
}

rebase_and_resign () {
  local starting_ref="$1"
  local n_commits="$2"

  # USYNC: Keep this countdown_f and one below synced.
  # - Also note you can `export PW_REBASE_COUNTDOWN=...` from your shell
  #   and it will work in the exec.
  local countdown_f=".git/${PW_REBASE_COUNTDOWN:-put-wise-countdown}"

  printf "%s" "${n_commits}" > "${countdown_f}"

  # USYNC: Keep this prog_prefix and one below synced.
  local prog_prefix="Signing commits: "

  local orig_progress="${prog_prefix}${n_commits}..."
  printf "%s" "${orig_progress}"

  # Note this runs without errexit still enabled.
  resign_ci () {
    set -e
    local countdown_f=".git/${PW_REBASE_COUNTDOWN:-put-wise-countdown}"
    local cur_count="$(cat ${countdown_f})"
    local prog_prefix="Signing commits: "
    printf "\r%s%s..." "${prog_prefix}" "${cur_count}"
    git commit --amend --no-edit --allow-empty --no-verify -S -q
    printf "%s" "$((${cur_count} - 1))" > "${countdown_f}"
  }

  # The --exec option forbids newlines, the author likes to condense
  # whitespace for readability when debugging, and --exec expects a
  # final semicolon before the closing brace, which `declare -f` does
  # not print.
  local exec_cmd="$( \
    declare -f resign_ci \
    | tr -d '\n' \
    | sed \
      -e 's/ \+/ /g' \
      -e 's/}$/;}/' \
  )"

  local ret_code=0
  local errs
  # Capture stderr and let stdout spew.
  # - Note git-rebase emits '\r' to clear its progress,
  #   or at least there's \r in the output.
  errs="$( \
    git rebase -q --exec "${exec_cmd}; resign_ci" ${starting_ref} 3>&1 >&2 2>&3 3>&- \
    | tr -d '\r' \
    | sed '/Executing: resign_ci () { /d'
  )" || ret_code="$?"

  if [ -n "${errs}" ] || [ ${ret_code} != 0 ]; then
    >&2 echo
    >&2 echo "ERROR: \`git rebase --exec\` failed (${ret_code}):"
    >&2 echo
    >&2 echo "  $ git rebase --exec \"${exec_cmd}; resign_ci\" ${starting_ref}"
    >&2 echo
    echo "${errs}" | >&2 sed 's/^/  /'

    return 1
  else
    printf "\r%s" "$(echo "${orig_progress}" | sed 's/./ /g')"
    printf "\r%s\n" "Signed ${n_commits} commit(s)."
  fi

  command rm -- "${countdown_f}"
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  set -e

  source_deps

  git-rebase-sort-by-scope-protected-private "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "$@"
fi

