#!/usr/bin/env bash
# vim:tw=0:ts=2:sw=2:et:norl:ft=bash
# Author: Landon Bouma (landonb &#x40; retrosoft &#x2E; com)
# Project: https://github.com/DepoXy/git-put-wise#ðŸ¥¨
# License: MIT

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# USAGE: See way TMI notes in the sequence-editor script:
#         ~/.depoxy/ambers/bin/seq-editors/sort-by-scope-protected-private

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# NOTES:
#
# If seq. editor refuses to rebase, it prints errors to stdout.
#
# - E.g., git-rebase might fail and emit, "You have unstaged changes".
#
# If the sequence editor fails, git-rebase emits to stderr.
#
# - E.g., "...problem with the editor...", and/or "fatal: No rebase in progress?".

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# SAVVY: If no ${starting_ref}, git-rebase defaults to upstream ancestor.
#
# BWARE: If common ancestor is first-commit, it means the two branches
#        do not share a common history.
#
#        - More importantly, the rebase might conclude with unexpected
#          results, e.g., missing commits.

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

# This is the known Git rebase todo path.
# - SPIKE: Can we get this from `git` so it's not hardcoded?
GIT_REBASE_TODO_PATH=".git/rebase-merge/git-rebase-todo"

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

source_deps () {
  # Pull in WIP and post-rebase cmds (maybe_stash_changes, git_post_rebase_*).
  # - Also deps/logger.sh, deps/git-nubs.sh, lib/common_*, lib/dep_*.
  . "$(print_project_root)/bin/git-put-wise"
}

print_project_root () {
  printf "%s" "$(dirname -- "$(realpath -- "${BASH_SOURCE[0]}")")/.."
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

git-rebase-sort-by-scope-protected-private () {
  local starting_ref="$1"
  local use_magic_starting_ref="${2:-false}"
  local enable_gpg_sign_if_signingkey="${3:-false}"
  local insist_signing_key="${4:-false}"

  # CXREF: ~/.kit/git/git-put-wise/bin/seq-editor-sort-by-scope-protected-private
  local seq_editor
  seq_editor="$(must_locate_seq_editor)" \
    || return $?

  must_verify_starting_ref "${starting_ref}"

  local enable_gpg_sign=${enable_gpg_sign_if_signingkey}

  local gpg_sign
  gpg_sign="$( \
    insist_print_gpg_sign_arg ${enable_gpg_sign_if_signingkey} ${insist_signing_key}
  )" || return 1

  if [ -z "${gpg_sign}" ]; then
    enable_gpg_sign=false
  fi

  # ***

  local pop_after=false
  pop_after=$(maybe_stash_changes "git-rebase-sort-by-scope-protected-private")

  local head_sha_before_rebase
  head_sha_before_rebase="$(git rev-parse HEAD)"

  local rev_count_before_rebase
  rev_count_before_rebase="$(git rev-list HEAD --count)"

  local sort_from_commit=""
  sort_from_commit="$(print_sort_from_commit "${starting_ref}" \
    "${use_magic_starting_ref}" "${head_sha_before_rebase}")"

  local n_commits
  n_commits="$(git rev-list --count ${sort_from_commit}..HEAD)"

  # ***

  local already_sorted=false

  # Sets already_sorted=true and returns 1 if sorted but not signed;
  # Or sets already_sorted=false and returns 1 if not sorted; or
  # returns 0 if sorted, and signed if requested.
  if is_already_sorted_and_signed "${sort_from_commit}" "${enable_gpg_sign}" "${n_commits}" \
  ; then
    maybe_unstash_changes ${pop_after}

    return 0
  fi

  # ***

  . "${seq_editor}"

  local progress_orig_msg=""
  if ${PW_REBASE_COUNTDOWN_ALWAYS:-false} || ${enable_gpg_sign}; then \
    progress_orig_msg="$(prepare_progress_messaging "${n_commits}")"

    printf "%s\n" "${progress_orig_msg}"
  fi

  seq_editor_cache_options "${gpg_sign}"

  # ***

  local retcode=0

  git_prepare_push_resort_scoped_and_sign_commits \
    "${seq_editor}" \
    "${gpg_sign}" \
    "${sort_from_commit}" \
    "${already_sorted}" \
    "${n_commits}" \
    "${progress_orig_msg}" \
    || retcode=$?

  seq_editor_cleanup_rebase_files

  print_hint_if_rebase_incomplete_or_new_state_suspicious \
    "${head_sha_before_rebase}" "${rev_count_before_rebase}" "${retcode}"

  # Always run optional user hook (GIT_POST_REBASE_EXEC) and also pop WIP...
  if [ ${retcode} -ne 0 ] && [ -f "${GIT_REBASE_TODO_PATH}" ]; then
    # ... after rebase finishes (by appending exec to git-rebase-todo).
    git_post_rebase_exec_inject ${pop_after}

    # Remove the progress countdown `exec`'s, because Git prints "Executing: ..."
    # for each exec, which defeats the purpose.
    # - Note that setting '\\r\\033[2A' in the `sort_by_scope_exec` fcn.
    #   *sorta* works, but assumes the "Executing: " message was split
    #   across two lines (\033[2A moves the cursor up 2 lines). But even if
    #   that value is correct, the UX is too noisy and impossible to read.
    command sed -i'' "/^exec sort_by_scope_exec () {/d" "${GIT_REBASE_TODO_PATH}"
  else
    # ... now.

    # Unstash WIP, and run post-rebase user hooks (GIT_POST_REBASE_EXEC).
    # - TIMED: post-rebase takes a quick but noticeable sec. to run.
    # - SAVVY: Even if before and after HEAD SHA unchanged, if hard link
    #   was involved in any of the rebased commits, the hard link will
    #   have been broken.
    #   - MAYBE/2024-08-24: Avoid post-rebase exec when possible (when
    #     no hard links were harmed during the rebase).
    #     - Altly, can you run exec without calling `mr`?
    #       Because `mr` startup is what's slow.
    git_post_rebase_exec_run ${pop_after}
  fi

  return ${retcode}
}

# ***

must_locate_seq_editor () {
  local seq_editor="$(print_project_root)/bin/seq-editor-sort-by-scope-protected-private"

  if [ ! -e "${seq_editor}" ]; then
    >&2 echo "ERROR: Sequence editor missing or not executable: ${seq_editor}"

    return 1
  fi

  echo "${seq_editor}"
}

# ***

must_verify_starting_ref () {
  local starting_ref="$1"

  if [ -z "${starting_ref}" ]; then
    >&2 echo "ERROR: Please specify the rebase starting gitref"

    return 1
  fi

  if ! git rev-parse "${starting_ref}" >/dev/null 2>&1; then
    # What git-rebase would print.
    >&2 echo "ERROR: fatal: invalid upstream '${starting_ref}'"

    return 1
  fi

  if ! git merge-base --is-ancestor "${starting_ref}" "HEAD"; then
    >&2 echo "ERROR: The starting ref is not an ancestor: '${starting_ref}'"

    return 1
  fi

  return 0
}

# If 'starting_ref' is the latest commit, do the user a solid and replace
# with the upstream branch or pw/in commit.
# - Makes it easy to resort unpublished commits without having to specify
#   the commit, e.g., `git sort-by-scope HEAD true`. (Though more so
#   intended for automation (see '%' `tig` binding in DepoXy project)).
print_sort_from_commit () {
  local starting_ref="$1"
  local use_magic_starting_ref="$2"
  local head_sha_before_rebase="$3"

  if ! ${use_magic_starting_ref:-false}; then
    printf "%s" "${starting_ref}"

    return 0
  fi

  # Uses: git rev-parse --verify --end-of-options "${gitref}^{commit}" 2> /dev/null
  if ! git_is_same_commit "${starting_ref}" "${head_sha_before_rebase}"; then
    printf "%s" "${starting_ref}"

    return 0
  fi

  # Load: put_wise_suss_push_vars_and_rebase_sort_by_scope_automatic
  . "$(print_project_root)/lib/put_wise_push_remotes.sh"

  # The following vars are set by the sort_from_commit, etc., susser:
  local branch_name=""
  local local_release=""
  local remote_release=""
  local remote_liminal=""
  local remote_protected=""
  local remote_current=""
  local remote_name=""
  local sort_from_commit=""
  # BWARE: Calls git-fetch, so not the quickest command.
  >&2 put_wise_suss_push_vars_and_rebase_sort_by_scope_automatic \
    "rebase automatically"

  printf "%s" "${sort_from_commit}"
}

# ***

# SAVVY: `git rebase --verbose` prints progress on separate lines, e.g.,
#     Rebasing (1/n)
#     Rebasing (2/n)
#     ...
# - Whereas without it, each "Rebasing (1/n)" message writes to the same
#   line, afterwards being replaced by one final message (on success):
#     Successfully rebased and updated <ref>.

# git-rebase prints each exec, e.g.,
#   Executing: sort_by_scope_exec () { ... }
# which we'll filter out.

# Note there's a git-rebase -q|--quiet option, but doesn't seem to
# affect output.

# Note the git-rebase output includes escape sequences, so start-of-line
# matching won't work, e.g.,
#      -e '/^Executing: sort_by_scope_exec () { /d' \
#      -e '/^Successfully rebased and updated .*\.$/d' \

# Note this filters "Rebasing (n/N)" progress messages, so that we
# can replace the "Successfully rebased..." message with a custom
# message (as opposed to showing both messages, I know!). But the
# resort generally runs in a split second, faster than you'd care
# about, or could read, in the moment.

git_prepare_push_resort_scoped_and_sign_commits () {
  local seq_editor="$1"
  local gpg_sign="$2"
  local sort_from_commit="$3"
  local already_sorted="$4"
  local n_commits="$5"
  local progress_orig_msg="$6"

  local retcode=0

  local errs
  errs="$( \
    GIT_SEQUENCE_EDITOR="${seq_editor}" \
      git -c color.advice=always rebase -i --rebase-merges ${sort_from_commit} 3>&1 >&2 2>&3 3>&- \
      | sed \
        -e '/Rebasing ([0-9]\+\/[0-9]\+)/d' \
        -e '/Executing: sort_by_scope_exec () { /d' \
        -e '/Successfully rebased and updated .*\.$/d' \
      | tr -d '\r';
    return ${PIPESTATUS[0]}
  )" \
    || retcode=$?

  if [ -n "${errs}" ] || [ ${retcode} != 0 ]; then
    >&2 echo
    >&2 echo "ERROR: \`git rebase\` failed (${retcode}):"
    >&2 echo
    echo "${errs}" | >&2 sed 's/^/  /'
  else
    if [ -n "${progress_orig_msg}" ]; then
      local one_line_up="\033[1A"
      # Wipe out final 'pick' progress message.
      # - Move to first column (\r), and one_line_up).
      printf "\r${one_line_up}%s\r" "$(echo "${progress_orig_msg}" | sed 's/./ /g')"
    fi
    print_sorted_and_signed_message "${gpg_sign}" "${already_sorted}" "${n_commits}"
  fi

  return ${retcode}
}

print_hint_if_rebase_incomplete_or_new_state_suspicious () {
  local head_sha_before_rebase="$1"
  local rev_count_before_rebase="$2"
  local retcode="$3"

  if [ -f "${GIT_REBASE_TODO_PATH}" ]; then
    # git-rebase exited 1.
    echo
    echo "Looks like you got work to do!"
    # git-rebase exited nonzero. If not, our code is wrong.
    if [ ${retcode} -eq 0 ]; then
      echo
      echo "ERROR: rebase-todo found, but git-rebase exited zero"
    fi
  else
    local unexpected_changes_detected=false

    if [ -n "$(git diff ${head_sha_before_rebase}..HEAD)" ]; then
      >&2 echo
      >&2 echo "BWARE: The sort-by-scope resulted in changes."

      unexpected_changes_detected=true
    fi

    local rev_count_after_rebase
    rev_count_after_rebase="$(git rev-list HEAD --count)"

    if [ ${rev_count_before_rebase} -ne ${rev_count_after_rebase} ]; then
      >&2 echo "BWARE: The number of commits before and after rebase has changed."
      >&2 echo "- Count before: ${rev_count_before_rebase} / Count after: ${rev_count_after_rebase}"

      unexpected_changes_detected=true
    fi

    if ${unexpected_changes_detected}; then
      >&2 echo "- If you had to resolve conflicts, maybe this was you."
      >&2 echo "- If not, perhaps you should investigate."
      >&2 echo "Previous HEAD: ${head_sha_before_rebase}"
      >&2 echo "- Try:"
      >&2 echo
      >&2 echo "    git diff ${head_sha_before_rebase}..HEAD"
    fi

    # git-rebase exited zero. If not, our code is wrong.
    # - Or I (lb) assume it is. Obviously, git-rebase can fail for other,
    #   non-conflict reasons (e.g., bad args), but I assume the way the
    #   code works that it won't.
    if [ ${retcode} -ne 0 ]; then
      echo
      echo "ERROR: rebase-todo not found, but git-rebase exited nonzero"
    fi
  fi
}

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ #

main () {
  set -e

  source_deps

  git-rebase-sort-by-scope-protected-private "$@"
}

if [ "$0" = "${BASH_SOURCE[0]}" ]; then
  main "$@"
fi

